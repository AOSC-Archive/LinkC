#include "linkc_network_protocol.h"

char*	buffer[MAX_BUFFER_SIZE + STD_PACKAGE_SIZE + 1];	// 接收缓冲区
int	is_remain	= 0;	// 上次数据是否有剩余
int	Length 		= 0;	// 接收到数据的长度


int Recv(int sockfd, void *out, size_t out_size, int flag)
{
	if(is_remain == 1)	// 若上次数据有剩余
	{
		if(((LMH*)buffer)->MessageLength == Length)	// 若上次剩余的数据是一个完整的包
		{
			if(out_size < Length)						// 若输出缓冲小于现在的数据长度
			{
				fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,Length);
				return LINKC_FAILURE;
			}
			memecpy(out,buffer,Length);					// 复制数据
			Length		= 0;						// 重设长度
			is_remain	= 0;						// 设置为没有数据剩余
			return LINKC_SUCCESS;						// 返回成功
		}
		else if(((LMH*)buffer)->MessageLength > Length)	// 若上次剩余的数据大于一个完整包
		{
			if(out_size < Length)                           		// 若输出缓冲小于现在的数据长度
			{
				fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,((LMH*)buffer)->MessageLength);
				return LINKC_FAILURE;
			}
			memecpy(out,buffer,((LMH*)buffer)->MessageLength);		// 复制数据
			Length          = Length - ((LMH*)buffer)->MessageLength;	// 重设长度
			is_remain       = 1;						// 设置为有数据剩余
			return LINKC_SUCCESS;						// 返回成功
		}
		else						// 若上次剩余的数据小于一个包[数据不完整]
		{
			while(!Length >= ((LMH*)buffer)->MessageLength)			// 直到接收数据大于等于数据包长度
			{
				Length += recv(sockfd,buffer+Length,STD_PACKAGE_SIZE,0);
				if(Length > STD_PACKAGE_SIZE)
					fprintf(stderr,"This data is larger than Standard :: Now Size = %d\nNow Stop Rrcv\n",Length);
				if(Length > MAX_BUFFER_SIZE)
				{
					fprintf(stderr,"This data is beyond Recv :: Now Size = %d\n",Length);
					Length		= 0;				// 重设长度
					is_remain	= 0;				// 设置为没有数据
					return LINKC_FAILURE;
				}
			}
			if(((LMH*)buffer)->MessageLength == Length)		// 若本次接收的数据是一个完整的包
			{
				if(out_size < Length)						// 若输出缓冲小于现在的数据长度
				{
					fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,Length);
					return LINKC_FAILURE;
				}
				memecpy(out,buffer,Length);					// 复制数据
				Length		= 0;						// 重设长度
				is_remain	= 0;						// 设置为没有数据剩余
				return LINKC_SUCCESS;						// 返回成功
			}
			else if(((LMH*)buffer)->MessageLength > Length)		// 若本次接收的数据大于一个完整包
			{
				if(out_size < Length)                           		// 若输出缓冲小于现在的数据长度
				{
					fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,((LMH*)buffer)->MessageLength);
					return LINKC_FAILURE;
				}
				memecpy(out,buffer,((LMH*)buffer)->MessageLength);		// 复制数据
				Length          = Length - ((LMH*)buffer)->MessageLength;	// 重设长度
				is_remain       = 1;						// 设置为有数据剩余
				return LINKC_SUCCESS;						// 返回成功
			}
		}
	}
	else		//若上次数据没有剩余
	{
		while(!Length >= ((LMH*)buffer)->MessageLength)			// 直到接收数据大于等于数据包长度
		{
			Length += recv(sockfd,buffer+Length,STD_PACKAGE_SIZE,0);
			if(Length > STD_PACKAGE_SIZE)
				fprintf(stderr,"This data is larger than Standard :: Now Size = %d\nNow Stop Rrcv\n",Length);
			if(Length > MAX_BUFFER_SIZE)
			{
				fprintf(stderr,"This data is beyond Recv :: Now Size = %d\n",Length);
				Length		= 0;				// 重设长度
				is_remain	= 0;				// 设置为没有数据
				return LINKC_FAILURE;
			}
		}
		if(((LMH*)buffer)->MessageLength == Length)		// 若本次接收的数据是一个完整的包
		{
			if(out_size < Length)						// 若输出缓冲小于现在的数据长度
			{
				fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,Length);
				return LINKC_FAILURE;
			}
			memecpy(out,buffer,Length);					// 复制数据
			Length		= 0;						// 重设长度
			is_remain	= 0;						// 设置为没有数据剩余
			return LINKC_SUCCESS;						// 返回成功
		}
		else if(((LMH*)buffer)->MessageLength > Length)		// 若本次接收的数据大于一个完整包
		{
			if(out_size < Length)                           		// 若输出缓冲小于现在的数据长度
			{
				fprintf(stderr,"Out Buffer is too small to copy data!\nBuffer Size = %d\tData Size = %d\n",out_size,((LMH*)buffer)->MessageLength);
				return LINKC_FAILURE;
			}
			memecpy(out,buffer,((LMH*)buffer)->MessageLength);		// 复制数据
			Length          = Length - ((LMH*)buffer)->MessageLength;	// 重设长度
			is_remain       = 1;						// 设置为有数据剩余
			return LINKC_SUCCESS;						// 返回成功
		}
	}
	return LINKC_FAILURE;
}
